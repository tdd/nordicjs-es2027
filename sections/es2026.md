---
layout: cover
background: /covers/kira-auf-der-heide-v7jlNFuKF14-unsplash.jpg
---

# ES2026

Quite a few things are ready, so who knowsâ€¦

---

# ES2026: `Error.isError`

There was no foolproof way of determining that a value was, in fact, an `Error`-based instance (due to various well-known symbols allowing deep override of legacy heuristics).

```js
const error = new Error('oh dang!')
const syntaxError = new SyntaxError('Unexpected token: ðŸ’©')
const shadyError = {
  [Symbol.toStringTag]: () => '[object Error]',
  message: 'oh dang!'
}

Error.isError(error) // => true
Error.isError(syntaxError) // => true
Error.isError(shadyError) // => false
```

---

# ES2026: `Math.sumPrecise()`

Yes, `number`, double-precision floating numbers and IEEE-754â€¦

```js
const values = [1e20, 0.1, -1e20]
values.reduce((a, b) => a + b, 0) // => 0 ðŸ˜ 
Math.sumPrecise(values) // => 0.1 ðŸ˜Ž

0.1 + 0.2 // => The infamous 0.30000000000000004
Math.sumPrecise([0.1, 0.2]) // => 0.3
```

---

# ES2026: Native Base64 / hex transcoding

Sure, we've had these in Node, like, forever (and [yet](https://npmtrends.com/base64-js)â€¦).But not in the browser, for `ArrayBuffer` and friends.

**So it's about time.**

```js
new TextEncoder().encode('Hello there').toBase64()
// => 'SGVsbG8gdGhlcmU='

Uint8Array.fromHex('4e6f726469632e6a732072756c657a21')
// => Uint8Array([78, 111, 114, 100, 105, 99, 46, 106, 115, 32, 114, 117, 108, 101, 122, 33])

new TextDecoder().decode(Uint8Array.fromBase64('Tm9yZGljLmpzIHJ1bGV6IQ=='))
// => 'Nordic.js rulez!'
```

---

# ES2026? Temporal <span class="stage">stage 3</span>

This will (advantageously) replace Moment, Luxon, date-fns, etc. We already have `Intl` for formatting, but we're upping our game here. Immutable-style API, nanosecond precision, all TZ supported, distinguishes absolute and local time, duration vs. interval, etc.  Just awesome! Check out the [docs](https://tc39.es/proposal-temporal/docs/) and [cookbook](https://tc39.es/proposal-temporal/docs/cookbook.html)!

```js {1|1-3|2,4-5|3-4,6|none}
const time = Temporal.PlainTime.from('10:15:00')
const meeting1 = Temporal.PlainDateTime.from('2025-10-02').withPlainTime(time)
const meeting2 = Temporal.PlainDateTime.from('2025-10-30').withPlainTime(time)
const timeZone = 'Europe/Stockholm'
meeting1.toZonedDateTime(timeZone).toInstant() // => 2025-10-02T08:15:00Z
meeting2.toZonedDateTime(timeZone).toInstant() // => 2025-10-30T09:15:00Z
```

<v-click at="-1">

```js {none|1-2|1-3|5|1,5-7}
const departure = Temporal.ZonedDateTime.from('2020-03-08T11:55:00+08:00[Asia/Hong_Kong]')
const arrival = Temporal.ZonedDateTime.from('2020-03-08T09:50:00-07:00[America/Los_Angeles]')
departure.until(arrival).toString() // => 'PT12H55M'

const flightTime = Temporal.Duration.from({ hours: 14, minutes: 10 }); // or { minutes: 850 }
const parisArrival = departure.add(flightTime).withTimeZone('Europe/Paris');
parisArrival.toString() // => '2020-03-08T19:05:00+01:00[Europe/Paris]')
```

</v-click>

# E2026? `Array.fromAsync(â€¦)` <span class="stage">stage 3</span>

We've had `Array.from(â€¦)` since ES2015, that consumes any **synchronous iterable** to turn it into an actual array.

We'll likely get `Array.fromAsync(â€¦)`, that does the same thing with **async iterables**.

```js
// Reads all STDIN (readable stream) lines into an array
process.stdin.setEncoding('utf-8')
const inputLines = await Array.fromAsync(process.stdin)
```

```js
// Let's remove trailing whitespace / LF / CR, while we're at it
process.stdin.setEncoding('utf-8')
const inputLines = await Array.fromAsync(process.stdin, (line) => line.trimEnd())
```

---

# ES2026? Guaranteed resource cleanup <span class="stage">stage 3</span>

Finally a mechanism to guarantee resource disposal!

Quite like C#'s `using`, Python's `with` or Java's try-with-resources: disposes of the resource in a guaranteed way when the scope or closure is discarded.

Exists in synchronous and asynchronous variants.  Based on two new well-known symbols (`Symbol.dispose` et `Symbol.asyncDispose`), supported out-of-the-box by timers and streams.

```js
async function copy4K(s1, s2) {
  using f1 = await fs.promises.open(s1, constants.O_RDONLY),
        f2 = await fs.promises.open(s2, constants.O_WRONLY)

  const buffer = Buffer.alloc(4096)
  const { bytesRead } = await f1.read(buffer)
  await f2.write(buffer, 0, bytesRead)
} // 'f2' is disposed first, then 'f1' is disposed second
```

<Footnote>

Proposal's name: *Explicit Resource Management*. TypeScript 5.2+ and Babel 7.22+ support it. Early implementations in v8 (so Node, Chrome, Edgeâ€¦).

</Footnote>

---

# ES2026? Deferred ESM import evaluation

This is mostly developer ergonomics for lazy module evaluation.

The traditional dynamic import defers both loading and evaluating:

```js
function handleChartsTabClick() {
  const graphLib = await import('heavy-graph-lib')
  // â€¦
}
```

This new syntax doesn't necessarily defer loading, but defers **evaluating** until the first property access on the namespace, from anywhere in the dependent code:

```js
import defer * as graphLib from "heavy-graph-lib";
```

<Footnote>

However, the stage-2 [Deferred re-exports](https://github.com/tc39/proposal-deferred-reexports#readme) proposal, with its `export defer` syntax, enables platform-native "tree-shaking" that would defer *loading* of re-exported submodules until the matching export is actually imported by other code.

</Footnote>

---

# ES2026? Atomic `getOrInsert` on maps

A replacement of the former, horribly-named `emplace()` proposal for collection normalization, it focuses on atomic lookup with on-the-fly default insertion.

It's not so much a race condition thing (as Maps cannot be shared across workers), but a DX thing.

```js
function groupBy(propName, ...items) {
  const result = new Map()

  for (const item of items) {
    result.getOrInsert(item[propName], []).push(item)
  }

  return result
}
```

A companion `getOrInsertComputed` method allows for dynamic-defaults scenarios.

---

# ES2026? Timezone canonicalization

With timezones IANA names (e.g. `Europe/Stockholm`) finally becoming the norm, TZDB occasional changes, however rare (at most 1 identifier change per year), creates issues.

For instance, `Europe/Kiev` is outdated, the current standard uses `Europe/Kyiv`.

This accrues issues as developers cannot rely on stable values in their TZ name stores, test code, etc.  This proposal improves the spec, updates TZDB reliance and alters some behavior in `Intl` and `Temporal` to mitigate these issues.

In particular, a new `equals()` method on `Temporal.TimeZone` allows more flexible, time-resistant comparison than the `===` operator.
